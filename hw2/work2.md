# 软件工程 第三周作业
## 学号：41911241 
## 姓名：檀永正
# 使用Java的Profile工具探究插入排序中什么操作最耗时
## 1.什么是Profile
profile中文解释为轮廓，它是通过分析程序的性能，生成一张表示程序运行过程中函数执行占用CPU情况的图，从而方便用户优化程序的一种非常便捷的工具。
## 2.如何看懂火焰图
程序写好后使用Profile生成一张图，称为火焰图。  
### 关于y轴
火焰图中y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。
### 关于x轴  
x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。  
### 性能分析
火焰图就是看顶层的哪个函数占据的宽度最大。只要有"平顶"（plateaus），就表示该函数可能存在性能问题。
## 3.排序算法分析
首先通过Profile生成火焰图如下：
![排序算法火焰图](https://i.bmp.ovh/imgs/2022/03/171741f417f02fdd.png)
观察火焰图，可以发现方法java.util.Random(init)(long)调用次数最多，占用的时间最长。  
对应源代码为
```
int[] a = new int[100000];
        for (int i = 0; i < 100000; i++) {
            a[i] = new Random().nextInt(10000);
        }
```
对源代码进行改进：
```
int[] a = new int[100000];
        for (int i = 0; i < 100000; i++) {
            a[i] = (int) (Math.random() * 10000);
        }
```
再次通过Profile生成新的火焰图
![改进后的火焰图](https://i.bmp.ovh/imgs/2022/03/c024ac2d2f9c9589.png)
观察改进后的火焰图，可以看到java.long.Math.Random()及其子函数占用的时间大为减少。
## 4.总结
### Profile使用收获
通过对比改进前后的火焰图，可以看到，针对程序中占用时间最长的方法进行修改，可以大大提高程序的效率。
未解之谜
在程序优化过程中，我只修改了上述代码，但是函数调用情况变得复杂许多，猜测是因为时间缩短后程序运行的情况显示的更加细微了。
## 参考文献
[如何读懂火焰图](https://www.ruanyifeng.com/blog/2017/09/flame-graph.html)  
[使用Async-profiler 对程序性能优化实战](https://www.cnblogs.com/leihuazhe/p/11630466.html)